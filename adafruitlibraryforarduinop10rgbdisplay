NOTE- https://github.com/adafruit/RGB-matrix-Panel/blob/master/examples/PanelGFXDemo_16x32/PanelGFXDemo_16x32.ino from here i have downloaded the library for rgb p10 display
//EXAMPLE-1 RGBmatrixPanel.h
/*!
 * @file RGBmatrixPanel.h
 *
 * This is the documentation for Adafruit's RGB LED Matrix Panel library
 * for the Arduino platform.  It is designed to work with 16x32, 32x32 and
 * 32x64 panels.
 *
 * Adafruit invests time and resources providing this open source code,
 * please support Adafruit and open-source hardware by purchasing
 * products from Adafruit!
 *
 * Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon for
 * Adafruit Industries.
 *
 * BSD license, all text here must be included in any redistribution.
 *
 */

#ifndef RGBMATRIXPANEL_H
#define RGBMATRIXPANEL_H

#if ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#include "pins_arduino.h"
#endif
#include "Adafruit_GFX.h"

#if defined(__AVR__)
typedef uint8_t PortType;
#elif defined(__arm__) || defined(__xtensa__)
typedef uint32_t PortType; // Formerly 'RwReg' but interfered w/CMCIS header
#endif

/*!
    @brief  Class encapsulating RGB LED matrix functionality.
*/
class RGBmatrixPanel : public Adafruit_GFX {

public:
  /*!
    @brief  Constructor for 16x32 panel.
    @param  a        Address/row-select A pin number.
    @param  b        Address/row-select B pin number.
    @param  c        Address/row-select C pin number.
    @param  clk      RGB clock pin number.
    @param  lat      RGB latch pin number.
    @param  oe       Output enable pin number.
    @param  dbuf     If true, display is double-buffered, allowing for
                     smoother animation (requires 2X RAM).
    @note   pinlist  (SAMD only) uint8_t array of 6 pin numbers corresponding
                     to upper R, G, B and lower R, G, B pins.
  */
  RGBmatrixPanel(uint8_t a, uint8_t b, uint8_t c, uint8_t clk, uint8_t lat,
                 uint8_t oe, boolean dbuf
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
                 ,
                 uint8_t *pinlist = NULL
#endif
  );

  /*!
    @brief  Constructor for 32x32 or 32x64 panel.
    @param  a        Address/row-select A pin number.
    @param  b        Address/row-select B pin number.
    @param  c        Address/row-select C pin number.
    @param  d        Address/row-select D pin number.
    @param  clk      RGB clock pin number.
    @param  lat      RGB latch pin number.
    @param  oe       Output enable pin number.
    @param  dbuf     If true, display is double-buffered, allowing for
                     smoother animation (requires 2X RAM).
    @param  width    Specify 32 or 64 for the two supported matrix widths
                     (default is 32).
    @note   pinlist  (SAMD only) uint8_t array of 6 pin numbers corresponding
                     to upper R, G, B and lower R, G, B pins.
  */
  RGBmatrixPanel(uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint8_t clk,
                 uint8_t lat, uint8_t oe, boolean dbuf, uint8_t width = 32
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
                 ,
                 uint8_t *pinlist = NULL
#endif
  );

  /*!
    @brief  Start RGB matrix. Initializes timers and interrupts.
  */
  void begin(void);

  /*!
    @brief  Lowest-level pixel drawing function required by Adafruit_GFX.
            Does not have an immediate effect -- must call updateDisplay()
            after any drawing operations to refresh matrix contents.
    @param  x  Pixel column (horizontal).
    @param  y  Pixel row (vertical).
    @param  c  Pixel color (16-bit 5/6/5 color, but actual color on matrix
               will be decimated from this as it uses fewer bitplanes).
  */
  void drawPixel(int16_t x, int16_t y, uint16_t c);

  /*!
    @brief  Fill entire matrix a single color.
            Does not have an immediate effect -- must call updateDisplay()
            after any drawing operations to refresh matrix contents.
    @param  c  Color (16-bit 5/6/5 color, but actual color on matrix
               will be decimated from this as it uses fewer bitplanes).
  */
  void fillScreen(uint16_t c);

  /*!
    @brief  Refresh matrix contents following one or more drawing calls.
  */
  void updateDisplay(void);

  /*!
    @brief  If using double buffering, swap the front and back buffers.
  */
  void swapBuffers(boolean);

  /*!
    @brief  Dump display contents to the Serial Monitor, adding some
            formatting to simplify copy-and-paste of data as a PROGMEM-
            embedded image for another sketch. If using multiple dumps
            this way, you'll need to edit the output to change the 'img'
            name for each. Data can then be loaded back into the display
            using a pgm_read_byte() loop.
  */
  void dumpMatrix(void);

  /*!
    @brief   Get address of back buffer -- can then load/store data directly.
             Format is very strangely interleaved, used at the lowest level
             by the timer interrupt, and not an intuitive pixel sequence,
             so this will likely only be used with data previously stored
             from dumpMatrix().
    @return  uint8_t* pointer to back buffer.
  */
  uint8_t *backBuffer(void);

  /*!
    @brief   Promote 3-bits R,G,B (used by earlier versions of this library)
             to the '565' color format used in Adafruit_GFX. New code should
             not use this, it's provided for backward compatibility.
    @param   r  Red value, 0-7.
    @param   g  Green value, 0-7.
    @param   b  Blue value, 0-7.
    @return  16-bit '565' color as used by Adafruit_GFX, can then be passed
             to drawing functions. Actual colors issued to matrix will be
             decimated from this, since it uses fewer bitplanes.
  */
  uint16_t Color333(uint8_t r, uint8_t g, uint8_t b);

  /*!
    @brief   Promote 4-bits R,G,B (handled by the current version of this
             library) to the '565' color format used in Adafruit_GFX.
    @param   r  Red value, 0-15.
    @param   g  Green value, 0-15.
    @param   b  Blue value, 0-15.
    @return  16-bit '565' color as used by Adafruit_GFX, can then be passed
             to drawing functions. Actual colors issued to matrix will be
             decimated from this (back to 444), since it uses fewer bitplanes.
  */
  uint16_t Color444(uint8_t r, uint8_t g, uint8_t b);

  /*!
    @brief   Decimate 8-bits R,G,B (used in a lot of existing graphics code
             in other projects and languages) to the '565' color format used
             in Adafruit_GFX.
    @param   r  Red value, 0-255.
    @param   g  Green value, 0-255.
    @param   b  Blue value, 0-255.
    @return  16-bit '565' color as used by Adafruit_GFX, can then be passed
             to drawing functions. Actual colors issued to matrix will be
             further decimated from this, since it uses fewer bitplanes.
  */
  uint16_t Color888(uint8_t r, uint8_t g, uint8_t b);

  /*!
    @brief   Decimate 8-bits R,G,B (used in a lot of existing graphics code
             in other projects and languages) to the '565' color format used
             in Adafruit_GFX, applying gamma correction if requested.
    @param   r      Red value, 0-255.
    @param   g      Green value, 0-255.
    @param   b      Blue value, 0-255.
    @param   gflag  If true, run 8-bit inputs through gamma correction table.
    @return  16-bit '565' color as used by Adafruit_GFX, can then be passed
             to drawing functions. Actual colors issued to matrix will be
             further decimated from this, since it uses fewer bitplanes.
  */
  uint16_t Color888(uint8_t r, uint8_t g, uint8_t b, boolean gflag);

  /*!
    @brief   Convert hue, saturation, value (used in some existing graphics
             code in other projects and languages) to the '565' RGB color
             format used in Adafruit_GFX, with gamma correction if requested.
    @param   hue    Hue (0 to 1535).
    @param   sat    Saturation (0 (monochrome) to 255 (full color)).
    @param   val    Value (0 (darkest) to 255 (brightest)).
    @param   gflag  If true, apply gamma correction table.
    @return  16-bit '565' color as used by Adafruit_GFX, can then be passed
             to drawing functions. Actual colors issued to matrix will be
             decimated from this, since it uses fewer bitplanes.
  */
  uint16_t ColorHSV(long hue, uint8_t sat, uint8_t val, boolean gflag);

private:
  uint8_t *matrixbuff[2];     ///< Buffer pointers for double-buffering
  uint8_t nRows;              ///< Number of rows (derived from A/B/C/D pins)
  volatile uint8_t backindex; ///< Index (0-1) of back buffer
  volatile boolean swapflag;  ///< if true, swap on next vsync

  // Init/alloc code common to both constructors:
  void init(uint8_t rows, uint8_t a, uint8_t b, uint8_t c, uint8_t clk,
            uint8_t lat, uint8_t oe, boolean dbuf, uint8_t width
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
            ,
            uint8_t *rgbpins
#endif
  );

  uint8_t _clk;       ///< RGB clock pin number
  uint8_t _lat;       ///< RGB latch pin number
  uint8_t _oe;        ///< Output enable pin number
  uint8_t _a;         ///< Address/row-select A pin number
  uint8_t _b;         ///< Address/row-select B pin number
  uint8_t _c;         ///< Address/row-select C pin number
  uint8_t _d;         ///< Address/row-select D pin number
  PortType clkmask;   ///< RGB clock pin bitmask
  PortType latmask;   ///< RGB latch pin bitmask
  PortType oemask;    ///< Output enable pin bitmask
  PortType addramask; ///< Address/row-select A pin bitmask
  PortType addrbmask; ///< Address/row-select B pin bitmask
  PortType addrcmask; ///< Address/row-select C pin bitmask
  PortType addrdmask; ///< Address/row-select D pin bitmask
  // PORT register pointers (CLKPORT is hardcoded on AVR)
  volatile PortType *latport;   ///< RGB latch PORT register
  volatile PortType *oeport;    ///< Output enable PORT register
  volatile PortType *addraport; ///< Address/row-select A PORT register
  volatile PortType *addrbport; ///< Address/row-select B PORT register
  volatile PortType *addrcport; ///< Address/row-select C PORT register
  volatile PortType *addrdport; ///< Address/row-select D PORT register

#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
  uint8_t rgbpins[6];           ///< Pin numbers for 2x R,G,B bits
  volatile PortType *outsetreg; ///< RGB PORT bit set register
  volatile PortType *outclrreg; ///< RGB PORT bit clear register
  PortType rgbclkmask;          ///< Mask of all RGB bits + CLK
  PortType expand[256];         ///< 6-to-32 bit converter table
#endif

  volatile uint8_t row;      ///< Row counter for interrupt handler
  volatile uint8_t plane;    ///< Bitplane counter for interrupt handler
  volatile uint8_t *buffptr; ///< Current RGB pointer for interrupt handler
};

#endif // RGBMATRIXPANEL_H

//EXAMPLE-2 RGBmatrixPanel.cpp
/*!
 * @file RGBmatrixPanel.cpp
 *
 * @mainpage Adafruit RGB Matrix Panel library.
 *
 * @section intro_sec Introduction
 *
 * This is the documentation for Adafruit's RGB LED Matrix Panel library
 * for the Arduino platform.  It is designed to work with 16x32, 32x32 and
 * 32x64 panels.
 *
 * A few notes on the implementation:
 *
 * - To control LED brightness, traditional PWM is eschewed in favor of
 *   Binary Code Modulation (aka Bit Angle Modulation), which operates
 *   through a succession of periods each twice the length of the preceeding
 *   one (rather than a direct linear count a la PWM).
 *   <a href="http://www.batsocks.co.uk/readme/art_bcm_1.htm">It's explained
 *   well here.</a>
 *   I was initially skeptical, but it works exceedingly well in practice!
 *   And this uses considerably fewer CPU cycles than software PWM.
 *
 * - Although many control pins are software-configurable in the user's
 *   code, a couple things are tied to specific PORT registers.  It's just
 *   a lot faster this way -- port lookups take time.  Please see the notes
 *   later regarding wiring on "alternative" Arduino boards.
 *
 * - A tiny bit of inline assembly language is used in the most speed-
 *   critical section.  The C++ compiler wasn't making optimal use of the
 *   instruction set in what seemed like an obvious chunk of code.  Since
 *   it's only a few short instructions, this loop is also "unrolled" --
 *   each iteration is stated explicitly, not through a control loop.
 *
 * - The library is stuck with some decisions that were made in the heyday
 *   of 2K RAM AVR microcontrollers. For newer projects on SAMD, ESP32 and
 *   other 32-bit devices, consider using
 *   <a
 * href="https://github.com/adafruit/Adafruit_Protomatter">Adafruit_Protomatter</a>
 *   instead, which offers more flexible support of size and color depth.
 *
 * Adafruit invests time and resources providing this open source code,
 * please support Adafruit and open-source hardware by purchasing
 * products from Adafruit!
 *
 * @section dependencies Dependencies
 *
 * This library depends on <a
 * href="https://github.com/adafruit/Adafruit-GFX-Library"> Adafruit_GFX</a>
 * being present on your system. Please make sure you have installed the latest
 * version before using this library.
 *
 * @section author Author
 *
 * Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon for
 * Adafruit Industries.
 *
 * @section license License
 *
 * BSD license, all text here must be included in any redistribution.
 *
 */

#include "RGBmatrixPanel.h"
#include "gamma.h"

#ifdef ARDUINO_ARCH_ESP32
#include "driver/timer.h"
#include "freertos/FreeRTOS.h"
#include <string.h>
#endif

#ifndef _swap_int16_t
#define _swap_int16_t(a, b)                                                    \
  {                                                                            \
    int16_t t = a;                                                             \
    a = b;                                                                     \
    b = t;                                                                     \
  } ///< 16-bit var swap
#endif

// A full PORT register is required for the data lines, though only the
// top 6 output bits are used.  For performance reasons, the port # cannot
// be changed via library calls, only by changing constants in the library.
// For similar reasons, the clock pin is only semi-configurable...it can
// be specified as any pin within a specific PORT register stated below.

#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
// Arduino Mega is now tested and confirmed, with the following caveats:
// Because digital pins 2-7 don't map to a contiguous port register,
// the Mega requires connecting the matrix data lines to different pins.
// Digital pins 24-29 are used for the data interface, and 22 & 23 are
// unavailable for other outputs because the software needs to write to
// the full PORTA register for speed.  Clock may be any pin on PORTB --
// on the Mega, this CAN'T be pins 8 or 9 (these are on PORTH), thus the
// wiring will need to be slightly different than the tutorial's
// explanation on the Uno, etc.  Pins 10-13 are all fair game for the
// clock, as are pins 50-53.
#define DATAPORT PORTA ///< RGB data PORT register
#define DATADIR DDRA   ///< RGB data direction register
#define CLKPORT PORTB  ///< RGB clock PORT register
#elif defined(__AVR_ATmega32U4__)
// Arduino Leonardo: this is vestigial code an unlikely to ever be
// finished -- DO NOT USE!!!  Unlike the Uno, digital pins 2-7 do NOT
// map to a contiguous port register, dashing our hopes for compatible
// wiring.  Making this work would require significant changes both to
// the bit-shifting code in the library, and how this board is wired to
// the LED matrix.  Bummer.
#define DATAPORT PORTD ///< RGB data PORT register
#define DATADIR DDRD   ///< RGB data direction register
#define CLKPORT PORTB  ///< RGB clock PORT register
#elif defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
// Support for ATSAMD21-based boards, done with PortType!
#else
// Ports for "standard" boards (Arduino Uno, Duemilanove, etc.)
#define DATAPORT PORTD ///< RGB data PORT register
#define DATADIR DDRD   ///< RGB data direction register
#define CLKPORT PORTB  ///< RGB clock PORT register
#endif

#define nPlanes 4 ///< Bit depth per R,G,B (4 = (2^4)^3 = 4096 colors)

// The fact that the display driver interrupt stuff is tied to the
// singular Timer1 doesn't really take well to object orientation with
// multiple RGBmatrixPanel instances.  The solution at present is to
// allow instances, but only one is active at any given time, via its
// begin() method.  The implementation is still incomplete in parts;
// the prior active panel really should be gracefully disabled, and a
// stop() method should perhaps be added...assuming multiple instances
// are even an actual need.
static RGBmatrixPanel *activePanel = NULL; ///< Active RGB panel object

// Code common to both the 16x32 and 32x32 constructors:
void RGBmatrixPanel::init(uint8_t rows, uint8_t a, uint8_t b, uint8_t c,
                          uint8_t clk, uint8_t lat, uint8_t oe, boolean dbuf,
                          uint8_t width
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
                          ,
                          uint8_t *pinlist
#endif
) {
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
  // R1, G1, B1, R2, G2, B2 pins
  static const uint8_t defaultrgbpins[] = {2, 3, 4, 5, 6, 7};
  memcpy(rgbpins, pinlist ? pinlist : defaultrgbpins, sizeof rgbpins);
#if defined(ARDUINO_ARCH_SAMD)
  // All six RGB pins MUST be on the same PORT # as CLK
  int clkportnum = g_APinDescription[clk].ulPort;
  for (uint8_t i = 0; i < 6; i++) {
    if (g_APinDescription[rgbpins[i]].ulPort != clkportnum)
      return;
  }
#endif
#endif

  nRows = rows; // Number of multiplexed rows; actual height is 2X this

  // Allocate and initialize matrix buffer:
  int buffsize = width * nRows * 3, // x3 = 3 bytes holds 4 planes "packed"
      allocsize = (dbuf == true) ? (buffsize * 2) : buffsize;
  if (NULL == (matrixbuff[0] = (uint8_t *)malloc(allocsize)))
    return;
  memset(matrixbuff[0], 0, allocsize);
  // If not double-buffered, both buffers then point to the same address:
  matrixbuff[1] = (dbuf == true) ? &matrixbuff[0][buffsize] : matrixbuff[0];

  // Save pin numbers for use by begin() method later.
  _a = a;
  _b = b;
  _c = c;
  _clk = clk;
  _lat = lat;
  _oe = oe;

  // Look up port registers and pin masks ahead of time,
  // avoids many slow digitalWrite() calls later.
  clkmask = digitalPinToBitMask(clk);
  latport = portOutputRegister(digitalPinToPort(lat));
  latmask = digitalPinToBitMask(lat);
  oeport = portOutputRegister(digitalPinToPort(oe));
  oemask = digitalPinToBitMask(oe);
  addraport = portOutputRegister(digitalPinToPort(a));
  addramask = digitalPinToBitMask(a);
  addrbport = portOutputRegister(digitalPinToPort(b));
  addrbmask = digitalPinToBitMask(b);
  addrcport = portOutputRegister(digitalPinToPort(c));
  addrcmask = digitalPinToBitMask(c);
  plane = nPlanes - 1;
  row = nRows - 1;
  swapflag = false;
  backindex = 0; // Array index of back buffer
}

// Constructor for 16x32 panel:
RGBmatrixPanel::RGBmatrixPanel(uint8_t a, uint8_t b, uint8_t c, uint8_t clk,
                               uint8_t lat, uint8_t oe, boolean dbuf
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
                               ,
                               uint8_t *pinlist
#endif
                               )
    : Adafruit_GFX(32, 16) {
  init(8, a, b, c, clk, lat, oe, dbuf, 32
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
       ,
       pinlist
#endif
  );
}

// Constructor for 32x32 or 32x64 panel:
RGBmatrixPanel::RGBmatrixPanel(uint8_t a, uint8_t b, uint8_t c, uint8_t d,
                               uint8_t clk, uint8_t lat, uint8_t oe,
                               boolean dbuf, uint8_t width
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
                               ,
                               uint8_t *pinlist
#endif
                               )
    : Adafruit_GFX(width, 32) {

  init(16, a, b, c, clk, lat, oe, dbuf, width
#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
       ,
       pinlist
#endif
  );

  // Init a few extra 32x32-specific elements:
  _d = d;
  addrdport = portOutputRegister(digitalPinToPort(d));
  addrdmask = digitalPinToBitMask(d);
}

#if defined(ARDUINO_ARCH_SAMD)
#define TIMER TC4
#define IRQN TC4_IRQn
#define IRQ_HANDLER TC4_Handler
#define TIMER_GCLK_ID TC4_GCLK_ID
#elif defined(ARDUINO_ARCH_ESP32)
IRAM_ATTR void IRQ_HANDLER(void *);
#endif

void RGBmatrixPanel::begin(void) {

  backindex = 0;                       // Back buffer
  buffptr = matrixbuff[1 - backindex]; // -> front buffer
  activePanel = this;                  // For interrupt hander

  // Enable all comm & address pins as outputs, set default states:
  pinMode(_clk, OUTPUT);
  digitalWrite(_clk, LOW); // Low
  pinMode(_lat, OUTPUT);
  *latport &= ~latmask; // Low
  pinMode(_oe, OUTPUT);
  *oeport |= oemask; // High (disable output)
  pinMode(_a, OUTPUT);
  *addraport &= ~addramask; // Low
  pinMode(_b, OUTPUT);
  *addrbport &= ~addrbmask; // Low
  pinMode(_c, OUTPUT);
  *addrcport &= ~addrcmask; // Low
  if (nRows > 8) {
    pinMode(_d, OUTPUT);
    *addrdport &= ~addrdmask; // Low
  }

#if defined(__AVR__)

  // The high six bits of the data port are set as outputs;
  // Might make this configurable in the future, but not yet.
  DATADIR = B11111100;
  DATAPORT = 0;

#elif defined(ARDUINO_ARCH_SAMD)

  // Semi-configurable RGB bits; must be on same PORT as CLK
  int clkportnum = g_APinDescription[_clk].ulPort;
#ifdef __SAMD51__ // No IOBUS on SAMD51
  outsetreg = &(PORT->Group[clkportnum].OUTSET.reg);
  outclrreg = &(PORT->Group[clkportnum].OUTCLR.reg);
#else
  outsetreg = &(PORT_IOBUS->Group[clkportnum].OUTSET.reg);
  outclrreg = &(PORT_IOBUS->Group[clkportnum].OUTCLR.reg);
#endif

  PortType rgbmask[6];
  clkmask = rgbclkmask = digitalPinToBitMask(_clk);
  for (uint8_t i = 0; i < 6; i++) {
    pinMode(rgbpins[i], OUTPUT);
    rgbmask[i] = digitalPinToBitMask(rgbpins[i]); // Pin bit mask
    rgbclkmask |= rgbmask[i];                     // Add to RGB+CLK bit mask
  }
  for (int i = 0; i < 256; i++) {
    expand[i] = 0;
    if (i & 0x04)
      expand[i] |= rgbmask[0];
    if (i & 0x08)
      expand[i] |= rgbmask[1];
    if (i & 0x10)
      expand[i] |= rgbmask[2];
    if (i & 0x20)
      expand[i] |= rgbmask[3];
    if (i & 0x40)
      expand[i] |= rgbmask[4];
    if (i & 0x80)
      expand[i] |= rgbmask[5];
  }
#elif defined(ARDUINO_ARCH_ESP32)
  // Semi-configurable RGB bits; must be on same PORT as CLK
  if (_clk < 32) {
    outsetreg = &GPIO.out_w1ts;
    outclrreg = &GPIO.out_w1tc;
  } else {
    outsetreg = (volatile PortType *)&(GPIO.out1_w1ts);
    outclrreg = (volatile PortType *)&(GPIO.out1_w1tc);
  }

  PortType rgbmask[6];
  clkmask = rgbclkmask = digitalPinToBitMask(_clk);
  for (uint8_t i = 0; i < 6; i++) {
    pinMode(rgbpins[i], OUTPUT);
    rgbmask[i] = digitalPinToBitMask(rgbpins[i]); // Pin bit mask
    rgbclkmask |= rgbmask[i];                     // Add to RGB+CLK bit mask
  }
  for (int i = 0; i < 256; i++) {
    expand[i] = 0;
    if (i & 0x04)
      expand[i] |= rgbmask[0];
    if (i & 0x08)
      expand[i] |= rgbmask[1];
    if (i & 0x10)
      expand[i] |= rgbmask[2];
    if (i & 0x20)
      expand[i] |= rgbmask[3];
    if (i & 0x40)
      expand[i] |= rgbmask[4];
    if (i & 0x80)
      expand[i] |= rgbmask[5];
  }
#endif

#if defined(ARDUINO_ARCH_ESP32)
  timer_config_t tim_config;
  tim_config.divider = 2; // Run Timer at 40 MHz
  tim_config.counter_dir = TIMER_COUNT_UP;
  tim_config.counter_en = TIMER_PAUSE;
  tim_config.alarm_en = TIMER_ALARM_EN;
  tim_config.auto_reload = TIMER_AUTORELOAD_EN;
  tim_config.intr_type = TIMER_INTR_LEVEL;

  timer_init(TIMER_GROUP_1, TIMER_0, &tim_config);
  /* Timer's counter will initially start from value below.
       Also, if auto_reload is set, this value will be automatically reload on
     alarm */
  timer_set_counter_value(TIMER_GROUP_1, TIMER_0, 0x00000000ULL);
  /* Configure the alarm value and the interrupt on alarm. */
  timer_set_alarm_value(TIMER_GROUP_1, TIMER_0, 10000);
  timer_enable_intr(TIMER_GROUP_1, TIMER_0);
  timer_isr_register(TIMER_GROUP_1, TIMER_0, IRQ_HANDLER, (void *)TIMER_0,
                     ESP_INTR_FLAG_IRAM, NULL);

  timer_start(TIMER_GROUP_1, TIMER_0);
#endif

#if defined(__AVR__)
  // Set up Timer1 for interrupt:
  TCCR1A = _BV(WGM11);                          // Mode 14 (fast PWM), OC1A off
  TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // Mode 14, no prescale
  ICR1 = 100;
  TIMSK1 |= _BV(TOIE1); // Enable Timer1 interrupt
  sei();                // Enable global interrupts
#endif

#if defined(ARDUINO_ARCH_SAMD)
#ifdef __SAMD51__
  // Set up generic clock gen 2 as source for TC4
  // Datasheet recommends setting GENCTRL register in a single write,
  // so a temp value is used here to more easily construct a value.
  GCLK_GENCTRL_Type genctrl;
  genctrl.bit.SRC = GCLK_GENCTRL_SRC_DFLL_Val; // 48 MHz source
  genctrl.bit.GENEN = 1;                       // Enable
  genctrl.bit.OE = 1;
  genctrl.bit.DIVSEL = 0; // Do not divide clock source
  genctrl.bit.DIV = 0;
  GCLK->GENCTRL[2].reg = genctrl.reg;
  while (GCLK->SYNCBUSY.bit.GENCTRL1 == 1)
    ;

  GCLK->PCHCTRL[TIMER_GCLK_ID].bit.CHEN = 0;
  while (GCLK->PCHCTRL[TIMER_GCLK_ID].bit.CHEN)
    ; // Wait for disable
  GCLK_PCHCTRL_Type pchctrl;
  pchctrl.bit.GEN = GCLK_PCHCTRL_GEN_GCLK2_Val;
  pchctrl.bit.CHEN = 1;
  GCLK->PCHCTRL[TIMER_GCLK_ID].reg = pchctrl.reg;
  while (!GCLK->PCHCTRL[TIMER_GCLK_ID].bit.CHEN)
    ; // Wait for enable

  // Counter must first be disabled to configure it
  TIMER->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
  while (TIMER->COUNT16.SYNCBUSY.bit.STATUS)
    ;

  TIMER->COUNT16.CTRLA.reg =    // Configure timer counter
      TC_CTRLA_PRESCALER_DIV1 | // 1:1 Prescale
      TC_CTRLA_MODE_COUNT16;    // 16-bit counter mode

  TIMER->COUNT16.WAVE.bit.WAVEGEN = 1; // Match frequency mode (MFRQ)

  TIMER->COUNT16.CTRLBSET.reg = TCC_CTRLBCLR_DIR; // Count DOWN
  while (TIMER->COUNT16.SYNCBUSY.bit.CTRLB)
    ;

  TIMER->COUNT16.CC[0].reg = 10000; // Compare value for channel 0
  while (TIMER->COUNT16.SYNCBUSY.bit.CC0)
    ;

  TIMER->COUNT16.INTENSET.reg = TC_INTENSET_OVF; // Enable overflow interrupt

  NVIC_DisableIRQ(IRQN);
  NVIC_ClearPendingIRQ(IRQN);
  NVIC_SetPriority(IRQN, 0); // Top priority
  NVIC_EnableIRQ(IRQN);

  // Enable TCx
  TIMER->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
  while (TIMER->COUNT16.SYNCBUSY.bit.STATUS)
    ;
#else
  // Enable GCLK for TC4 and COUNTER (timer counter input clock)
  GCLK->CLKCTRL.reg = (uint16_t)(GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 |
                                 GCLK_CLKCTRL_ID(GCM_TC4_TC5));
  while (GCLK->STATUS.bit.SYNCBUSY == 1)
    ;

  // Counter must first be disabled to configure it
  TIMER->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;

  TIMER->COUNT16.CTRLA.reg =    // Configure timer counter
      TC_CTRLA_PRESCALER_DIV1 | // 1:1 Prescale
      TC_CTRLA_WAVEGEN_MFRQ |   // Match frequency generation mode (MFRQ)
      TC_CTRLA_MODE_COUNT16;    // 16-bit counter mode
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;

  //  TIMER->COUNT16.CTRLBCLR.reg = TCC_CTRLBCLR_DIR; // Count up
  TIMER->COUNT16.CTRLBSET.reg = TCC_CTRLBCLR_DIR; // Count DOWN
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;

  TIMER->COUNT16.CC[0].reg = 10000; // Compare value for channel 0
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;

  TIMER->COUNT16.INTENSET.reg = TC_INTENSET_OVF; // Enable overflow interrupt

  NVIC_DisableIRQ(IRQN);
  NVIC_ClearPendingIRQ(IRQN);
  NVIC_SetPriority(IRQN, 0); // Top priority
  NVIC_EnableIRQ(IRQN);

  // Enable TCx
  TIMER->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;
#endif // SAMD21
#endif // ARDUINO_ARCH_SAMD
}

// Original RGBmatrixPanel library used 3/3/3 color.  Later version used
// 4/4/4.  Then Adafruit_GFX (core library used across all Adafruit
// display devices now) standardized on 5/6/5.  The matrix still operates
// internally on 4/4/4 color, but all the graphics functions are written
// to expect 5/6/5...the matrix lib will truncate the color components as
// needed when drawing.  These next functions are mostly here for the
// benefit of older code using one of the original color formats.

// Promote 3/3/3 RGB to Adafruit_GFX 5/6/5
uint16_t RGBmatrixPanel::Color333(uint8_t r, uint8_t g, uint8_t b) {
  // RRRrrGGGgggBBBbb
  return ((r & 0x7) << 13) | ((r & 0x6) << 10) | ((g & 0x7) << 8) |
         ((g & 0x7) << 5) | ((b & 0x7) << 2) | ((b & 0x6) >> 1);
}

// Promote 4/4/4 RGB to Adafruit_GFX 5/6/5
uint16_t RGBmatrixPanel::Color444(uint8_t r, uint8_t g, uint8_t b) {
  // RRRRrGGGGggBBBBb
  return ((r & 0xF) << 12) | ((r & 0x8) << 8) | ((g & 0xF) << 7) |
         ((g & 0xC) << 3) | ((b & 0xF) << 1) | ((b & 0x8) >> 3);
}

// Demote 8/8/8 to Adafruit_GFX 5/6/5
// If no gamma flag passed, assume linear color
uint16_t RGBmatrixPanel::Color888(uint8_t r, uint8_t g, uint8_t b) {
  return ((uint16_t)(r & 0xF8) << 8) | ((uint16_t)(g & 0xFC) << 3) | (b >> 3);
}

// 8/8/8 -> gamma -> 5/6/5
uint16_t RGBmatrixPanel::Color888(uint8_t r, uint8_t g, uint8_t b,
                                  boolean gflag) {
  if (gflag) {                          // Gamma-corrected color?
    r = pgm_read_byte(&gamma_table[r]); // Gamma correction table maps
    g = pgm_read_byte(&gamma_table[g]); // 8-bit input to 4-bit output
    b = pgm_read_byte(&gamma_table[b]);
    return ((uint16_t)r << 12) | ((uint16_t)(r & 0x8) << 8) | // 4/4/4->5/6/5
           ((uint16_t)g << 7) | ((uint16_t)(g & 0xC) << 3) | (b << 1) |
           (b >> 3);
  } // else linear (uncorrected) color
  return ((uint16_t)(r & 0xF8) << 8) | ((uint16_t)(g & 0xFC) << 3) | (b >> 3);
}

uint16_t RGBmatrixPanel::ColorHSV(long hue, uint8_t sat, uint8_t val,
                                  boolean gflag) {

  uint8_t r, g, b, lo;
  uint16_t s1, v1;

  // Hue
  hue %= 1536; // -1535 to +1535
  if (hue < 0)
    hue += 1536;      //     0 to +1535
  lo = hue & 255;     // Low byte  = primary/secondary color mix
  switch (hue >> 8) { // High byte = sextant of colorwheel
  case 0:
    r = 255;
    g = lo;
    b = 0;
    break; // R to Y
  case 1:
    r = 255 - lo;
    g = 255;
    b = 0;
    break; // Y to G
  case 2:
    r = 0;
    g = 255;
    b = lo;
    break; // G to C
  case 3:
    r = 0;
    g = 255 - lo;
    b = 255;
    break; // C to B
  case 4:
    r = lo;
    g = 0;
    b = 255;
    break; // B to M
  default:
    r = 255;
    g = 0;
    b = 255 - lo;
    break; // M to R
  }

  // Saturation: add 1 so range is 1 to 256, allowig a quick shift operation
  // on the result rather than a costly divide, while the type upgrade to int
  // avoids repeated type conversions in both directions.
  s1 = sat + 1;
  r = 255 - (((255 - r) * s1) >> 8);
  g = 255 - (((255 - g) * s1) >> 8);
  b = 255 - (((255 - b) * s1) >> 8);

  // Value (brightness) & 16-bit color reduction: similar to above, add 1
  // to allow shifts, and upgrade to int makes other conversions implicit.
  v1 = val + 1;
  if (gflag) { // Gamma-corrected color?
    r = pgm_read_byte(
        &gamma_table[(r * v1) >> 8]); // Gamma correction table maps
    g = pgm_read_byte(
        &gamma_table[(g * v1) >> 8]); // 8-bit input to 4-bit output
    b = pgm_read_byte(&gamma_table[(b * v1) >> 8]);
  } else {              // linear (uncorrected) color
    r = (r * v1) >> 12; // 4-bit results
    g = (g * v1) >> 12;
    b = (b * v1) >> 12;
  }
  return (r << 12) | ((r & 0x8) << 8) | // 4/4/4 -> 5/6/5
         (g << 7) | ((g & 0xC) << 3) | (b << 1) | (b >> 3);
}

void RGBmatrixPanel::drawPixel(int16_t x, int16_t y, uint16_t c) {
  uint8_t r, g, b, bit, limit, *ptr;

  if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height))
    return;

  switch (rotation) {
  case 1:
    _swap_int16_t(x, y);
    x = WIDTH - 1 - x;
    break;
  case 2:
    x = WIDTH - 1 - x;
    y = HEIGHT - 1 - y;
    break;
  case 3:
    _swap_int16_t(x, y);
    y = HEIGHT - 1 - y;
    break;
  }

  // Adafruit_GFX uses 16-bit color in 5/6/5 format, while matrix needs
  // 4/4/4.  Pluck out relevant bits while separating into R,G,B:
  r = c >> 12;        // RRRRrggggggbbbbb
  g = (c >> 7) & 0xF; // rrrrrGGGGggbbbbb
  b = (c >> 1) & 0xF; // rrrrrggggggBBBBb

  // Loop counter stuff
  bit = 2;
  limit = 1 << nPlanes;

  if (y < nRows) {
    // Data for the upper half of the display is stored in the lower
    // bits of each byte.
    ptr = &matrixbuff[backindex][y * WIDTH * (nPlanes - 1) + x]; // Base addr
    // Plane 0 is a tricky case -- its data is spread about,
    // stored in least two bits not used by the other planes.
    ptr[WIDTH * 2] &= ~B00000011; // Plane 0 R,G mask out in one op
    if (r & 1)
      ptr[WIDTH * 2] |= B00000001; // Plane 0 R: 64 bytes ahead, bit 0
    if (g & 1)
      ptr[WIDTH * 2] |= B00000010; // Plane 0 G: 64 bytes ahead, bit 1
    if (b & 1)
      ptr[WIDTH] |= B00000001; // Plane 0 B: 32 bytes ahead, bit 0
    else
      ptr[WIDTH] &= ~B00000001; // Plane 0 B unset; mask out
    // The remaining three image planes are more normal-ish.
    // Data is stored in the high 6 bits so it can be quickly
    // copied to the DATAPORT register w/6 output lines.
    for (; bit < limit; bit <<= 1) {
      *ptr &= ~B00011100; // Mask out R,G,B in one op
      if (r & bit)
        *ptr |= B00000100; // Plane N R: bit 2
      if (g & bit)
        *ptr |= B00001000; // Plane N G: bit 3
      if (b & bit)
        *ptr |= B00010000; // Plane N B: bit 4
      ptr += WIDTH;        // Advance to next bit plane
    }
  } else {
    // Data for the lower half of the display is stored in the upper
    // bits, except for the plane 0 stuff, using 2 least bits.
    ptr = &matrixbuff[backindex][(y - nRows) * WIDTH * (nPlanes - 1) + x];
    *ptr &= ~B00000011; // Plane 0 G,B mask out in one op
    if (r & 1)
      ptr[WIDTH] |= B00000010; // Plane 0 R: 32 bytes ahead, bit 1
    else
      ptr[WIDTH] &= ~B00000010; // Plane 0 R unset; mask out
    if (g & 1)
      *ptr |= B00000001; // Plane 0 G: bit 0
    if (b & 1)
      *ptr |= B00000010; // Plane 0 B: bit 0
    for (; bit < limit; bit <<= 1) {
      *ptr &= ~B11100000; // Mask out R,G,B in one op
      if (r & bit)
        *ptr |= B00100000; // Plane N R: bit 5
      if (g & bit)
        *ptr |= B01000000; // Plane N G: bit 6
      if (b & bit)
        *ptr |= B10000000; // Plane N B: bit 7
      ptr += WIDTH;        // Advance to next bit plane
    }
  }
}

void RGBmatrixPanel::fillScreen(uint16_t c) {
  if ((c == 0x0000) || (c == 0xffff)) {
    // For black or white, all bits in frame buffer will be identically
    // set or unset (regardless of weird bit packing), so it's OK to just
    // quickly memset the whole thing:
    memset(matrixbuff[backindex], c, WIDTH * nRows * 3);
  } else {
    // Otherwise, need to handle it the long way:
    Adafruit_GFX::fillScreen(c);
  }
}

// Return address of back buffer -- can then load/store data directly
uint8_t *RGBmatrixPanel::backBuffer() { return matrixbuff[backindex]; }

// For smooth animation -- drawing always takes place in the "back" buffer;
// this method pushes it to the "front" for display.  Passing "true", the
// updated display contents are then copied to the new back buffer and can
// be incrementally modified.  If "false", the back buffer then contains
// the old front buffer contents -- your code can either clear this or
// draw over every pixel.  (No effect if double-buffering is not enabled.)
void RGBmatrixPanel::swapBuffers(boolean copy) {
  if (matrixbuff[0] != matrixbuff[1]) {
    // To avoid 'tearing' display, actual swap takes place in the interrupt
    // handler, at the end of a complete screen refresh cycle.
    swapflag = true; // Set flag here, then...
    while (swapflag == true)
      delay(1); // wait for interrupt to clear it
    if (copy == true)
      memcpy(matrixbuff[backindex], matrixbuff[1 - backindex],
             WIDTH * nRows * 3);
  }
}

// Dump display contents to the Serial Monitor, adding some formatting to
// simplify copy-and-paste of data as a PROGMEM-embedded image for another
// sketch.  If using multiple dumps this way, you'll need to edit the
// output to change the 'img' name for each.  Data can then be loaded
// back into the display using a pgm_read_byte() loop.
void RGBmatrixPanel::dumpMatrix(void) {

  int i, buffsize = WIDTH * nRows * 3;

  Serial.print(F("\n\n"
                 "#include <avr/pgmspace.h>\n\n"
                 "static const uint8_t PROGMEM img[] = {\n  "));

  for (i = 0; i < buffsize; i++) {
    Serial.print(F("0x"));
    if (matrixbuff[backindex][i] < 0x10)
      Serial.write('0');
    Serial.print(matrixbuff[backindex][i], HEX);
    if (i < (buffsize - 1)) {
      if ((i & 7) == 7)
        Serial.print(F(",\n  "));
      else
        Serial.write(',');
    }
  }
  Serial.println(F("\n};"));
}

// -------------------- Interrupt handler stuff --------------------

#if defined(__AVR__)

ISR(TIMER1_OVF_vect, ISR_BLOCK) { // ISR_BLOCK important -- see notes later
  activePanel->updateDisplay();   // Call refresh func for active display
  TIFR1 |= TOV1;                  // Clear Timer1 interrupt flag
}

#elif defined(ARDUINO_ARCH_SAMD)

void IRQ_HANDLER() {
  activePanel->updateDisplay(); // Call refresh func for active display
  TIMER->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF; // Clear overflow flag
}

#elif defined(ARDUINO_ARCH_ESP32)
IRAM_ATTR void IRQ_HANDLER(void *arg) {
  int timer_idx = (int)arg;
  /* Retrieve the interrupt status and the counter value
           from the timer that reported the interrupt */
  uint32_t intr_status = TIMERG1.int_st_timers.val;
  activePanel->updateDisplay(); // Call refresh func for active display
  /* Clear the interrupt
                   and update the alarm time for the timer with without reload
   */
  if ((intr_status & BIT(timer_idx)) && timer_idx == TIMER_0) {
    TIMERG1.int_clr_timers.t0 = 1;
  }
  /* After the alarm has been triggered
   we need enable it again, so it is triggered the next time */
  TIMERG1.hw_timer[timer_idx].config.alarm_en = TIMER_ALARM_EN;
}

#endif

// Two constants are used in timing each successive BCM interval.
// These were found empirically, by checking the value of TCNT1 at
// certain positions in the interrupt code.
// CALLOVERHEAD is the number of CPU 'ticks' from the timer overflow
// condition (triggering the interrupt) to the first line in the
// updateDisplay() method.  It's then assumed (maybe not entirely 100%
// accurately, but close enough) that a similar amount of time will be
// needed at the opposite end, restoring regular program flow.
// LOOPTIME is the number of 'ticks' spent inside the shortest data-
// issuing loop (not actually a 'loop' because it's unrolled, but eh).
// Both numbers are rounded up slightly to allow a little wiggle room
// should different compilers produce slightly different results.
#if defined(__AVR__)
#define CALLOVERHEAD 60 // Actual value measured = 56
#define LOOPTIME 200    // Actual value measured = 188
#endif
#if defined(ARDUINO_ARCH_SAMD)
#define CALLOVERHEAD 60 // Actual = 58
#define LOOPTIME 600    // Actual = 558
#endif
#if defined(ARDUINO_ARCH_ESP32)
#define CALLOVERHEAD 30 // Actual = 25
#define LOOPTIME 400    // Actual = 1563 / 4
#endif
// The "on" time for bitplane 0 (with the shortest BCM interval) can
// then be estimated as LOOPTIME + CALLOVERHEAD * 2.  Each successive
// bitplane then doubles the prior amount of time.  We can then
// estimate refresh rates from this:
// 4 bitplanes = 320 + 640 + 1280 + 2560 = 4800 ticks per row.
// 4800 ticks * 16 rows (for 32x32 matrix) = 76800 ticks/frame.
// 16M CPU ticks/sec / 76800 ticks/frame = 208.33 Hz.
// Actual frame rate will be slightly less due to work being done
// during the brief "LEDs off" interval...it's reasonable to say
// "about 200 Hz."  The 16x32 matrix only has to scan half as many
// rows...so we could either double the refresh rate (keeping the CPU
// load the same), or keep the same refresh rate but halve the CPU
// load.  We opted for the latter.
// Can also estimate CPU use: bitplanes 1-3 all use 320 ticks to
// issue data (the increasing gaps in the timing invervals are then
// available to other code), and bitplane 0 takes 920 ticks out of
// the 2560 tick interval.
// 320 * 3 + 920 = 1880 ticks spent in interrupt code, per row.
// From prior calculations, about 4800 ticks happen per row.
// CPU use = 1880 / 4800 = ~39% (actual use will be very slightly
// higher, again due to code used in the LEDs off interval).
// 16x32 matrix uses about half that CPU load.  CPU time could be
// further adjusted by padding the LOOPTIME value, but refresh rates
// will decrease proportionally, and 200 Hz is a decent target.

// The flow of the interrupt can be awkward to grasp, because data is
// being issued to the LED matrix for the *next* bitplane and/or row
// while the *current* plane/row is being shown.  As a result, the
// counter variables change between past/present/future tense in mid-
// function...hopefully tenses are sufficiently commented.
#if defined(ARDUINO_ARCH_ESP32)
IRAM_ATTR void RGBmatrixPanel::updateDisplay(void) {
#else
void RGBmatrixPanel::updateDisplay(void) {
#endif
  uint8_t i, tick, tock, *ptr;
  uint16_t t, duration;

  *oeport |= oemask;   // Disable LED output during row/plane switchover
  *latport |= latmask; // Latch data loaded during *prior* interrupt

  // Calculate time to next interrupt BEFORE incrementing plane #.
  // This is because duration is the display time for the data loaded
  // on the PRIOR interrupt.  CALLOVERHEAD is subtracted from the
  // result because that time is implicit between the timer overflow
  // (interrupt triggered) and the initial LEDs-off line at the start
  // of this method.
  t = (nRows > 8) ? LOOPTIME : (LOOPTIME * 2);
  duration = ((t + CALLOVERHEAD * 2) << plane) - CALLOVERHEAD;

  // Borrowing a technique here from Ray's Logic:
  // www.rayslogic.com/propeller/Programming/AdafruitRGB/AdafruitRGB.htm
  // This code cycles through all four planes for each scanline before
  // advancing to the next line.  While it might seem beneficial to
  // advance lines every time and interleave the planes to reduce
  // vertical scanning artifacts, in practice with this panel it causes
  // a green 'ghosting' effect on black pixels, a much worse artifact.

  if (++plane >= nPlanes) {   // Advance plane counter.  Maxed out?
    plane = 0;                // Yes, reset to plane 0, and
    if (++row >= nRows) {     // advance row counter.  Maxed out?
      row = 0;                // Yes, reset row counter, then...
      if (swapflag == true) { // Swap front/back buffers if requested
        backindex = 1 - backindex;
        swapflag = false;
      }
      buffptr = matrixbuff[1 - backindex]; // Reset into front buffer
    }
  } else if (plane == 1) {
    // Plane 0 was loaded on prior interrupt invocation and is about to
    // latch now, so update the row address lines before we do that:
    if (row & 0x1)
      *addraport |= addramask;
    else
      *addraport &= ~addramask;
    // MYSTERY: certain matrices REQUIRE these delays ???
    delayMicroseconds(10);
    if (row & 0x2)
      *addrbport |= addrbmask;
    else
      *addrbport &= ~addrbmask;
    delayMicroseconds(10);
    if (row & 0x4)
      *addrcport |= addrcmask;
    else
      *addrcport &= ~addrcmask;
    delayMicroseconds(10);
    if (nRows > 8) {
      if (row & 0x8)
        *addrdport |= addrdmask;
      else
        *addrdport &= ~addrdmask;
      delayMicroseconds(10);
    }
  }

  // buffptr, being 'volatile' type, doesn't take well to optimization.
  // A local register copy can speed some things up:
  ptr = (uint8_t *)buffptr;

#if defined(__AVR__)
  ICR1 = duration; // Set interval for next interrupt
  TCNT1 = 0;       // Restart interrupt timer
#elif defined(ARDUINO_ARCH_SAMD)
#ifdef __SAMD51__
  TIMER->COUNT16.CC[0].reg = duration;
  while (TIMER->COUNT16.SYNCBUSY.bit.CC0)
    ;
  TIMER->COUNT16.COUNT.reg = duration;
  while (TIMER->COUNT16.SYNCBUSY.bit.COUNT)
    ;
#else
  TIMER->COUNT16.CC[0].reg = duration;
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;
  TIMER->COUNT16.COUNT.reg = duration;
  while (TIMER->COUNT16.STATUS.bit.SYNCBUSY)
    ;
#endif // SAMD21
#elif defined(ARDUINO_ARCH_ESP32)
static timg_dev_t *TG[2] = {&TIMERG0, &TIMERG1};
static portMUX_TYPE timer_spinlock[TIMER_GROUP_MAX] = {
    portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED};
portENTER_CRITICAL(&timer_spinlock[TIMER_GROUP_1]);
TG[TIMER_GROUP_1]->hw_timer[TIMER_0].alarm_high = 0;
TG[TIMER_GROUP_1]->hw_timer[TIMER_0].alarm_low = (uint32_t)duration;
portEXIT_CRITICAL(&timer_spinlock[TIMER_GROUP_1]);
#endif                  // ARDUINO_ARCH_SAMD
  *oeport &= ~oemask;   // Re-enable output
  *latport &= ~latmask; // Latch down

  // Record current state of CLKPORT register, as well as a second
  // copy with the clock bit set.  This makes the innnermost data-
  // pushing loops faster, as they can just set the PORT state and
  // not have to load/modify/store bits every single time.  It's a
  // somewhat rude trick that ONLY works because the interrupt
  // handler is set ISR_BLOCK, halting any other interrupts that
  // might otherwise also be twiddling the port at the same time
  // (else this would clobber them). only needed for AVR's where you
  // cannot set one bit in a single instruction
#if defined(__AVR__)
  tock = CLKPORT;
  tick = tock | clkmask;
#endif

  if (plane > 0) { // 188 ticks from TCNT1=0 (above) to end of function

    // Planes 1-3 copy bytes directly from RAM to PORT without unpacking.
    // The least 2 bits (used for plane 0 data) are presumed masked out
    // by the port direction bits.

#if defined(__AVR__)
// A tiny bit of inline assembly is used; compiler doesn't pick
// up on opportunity for post-increment addressing mode.
// 5 instruction ticks per 'pew' = 160 ticks total
#define pew                                                                    \
  asm volatile(                                                                \
      "ld  __tmp_reg__, %a[ptr]+"                                              \
      "\n\t"                                                                   \
      "out %[data]    , __tmp_reg__"                                           \
      "\n\t"                                                                   \
      "out %[clk]     , %[tick]"                                               \
      "\n\t"                                                                   \
      "out %[clk]     , %[tock]"                                               \
      "\n" ::[ptr] "e"(ptr),                                                   \
      [data] "I"(_SFR_IO_ADDR(DATAPORT)), [clk] "I"(_SFR_IO_ADDR(CLKPORT)),    \
      [tick] "r"(tick), [tock] "r"(tock));
#elif defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
#ifdef __SAMD51__ // No IOBUS on SAMD51
#define pew                                                                    \
  *outclrreg = rgbclkmask;                                                     \
  *outsetreg = expand[*ptr++];                                                 \
  *outsetreg = clkmask;                                                        \
  asm("nop");
#else
#define pew                                                                    \
  *outclrreg = rgbclkmask;                                                     \
  *outsetreg = expand[*ptr++];                                                 \
  *outsetreg = clkmask;
#endif
#endif

    // Loop is unrolled for speed:
    pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew
        pew pew pew pew pew pew pew pew pew pew pew pew pew

        if (WIDTH == 64){
            pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew
                pew pew pew pew pew pew pew pew pew pew pew pew pew pew pew}

#if defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
            *outclrreg = clkmask; // Set clock low
#endif

    buffptr = ptr; //+= 32;

  } else { // 920 ticks from TCNT1=0 (above) to end of function
#if defined(__AVR__)
    // Planes 1-3 (handled above) formatted their data "in place,"
    // their layout matching that out the output PORT register (where
    // 6 bits correspond to output data lines), maximizing throughput
    // as no conversion or unpacking is needed.  Plane 0 then takes up
    // the slack, with all its data packed into the 2 least bits not
    // used by the other planes.  This works because the unpacking and
    // output for plane 0 is handled while plane 3 is being displayed...
    // because binary coded modulation is used (not PWM), that plane
    // has the longest display interval, so the extra work fits.
    for (i = 0; i < WIDTH; i++) {
      DATAPORT = (ptr[i] << 6) | ((ptr[i + WIDTH] << 4) & 0x30) |
                 ((ptr[i + WIDTH * 2] << 2) & 0x0C);
      CLKPORT = tick; // Clock lo
      CLKPORT = tock; // Clock hi
    }
#elif defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_ESP32)
    for (int i = 0; i < WIDTH; i++) {
      byte b = (ptr[i] << 6) | ((ptr[i + WIDTH] << 4) & 0x30) |
               ((ptr[i + WIDTH * 2] << 2) & 0x0C);

      *outclrreg = rgbclkmask; // Clear all data and clock bits together
      *outsetreg = expand[b];  // Set new data bits
      *outsetreg = clkmask;    // Set clock high
    }
    *outclrreg = clkmask; // Set clock low
#endif
  }
}

//EXAMPLE-3 gamma.h
#ifndef _GAMMA_H_
#define _GAMMA_H_

#ifdef __AVR__
#include <avr/pgmspace.h>
#elif defined(ESP8266) || defined(ESP32)
#include <pgmspace.h>
#endif

static const uint8_t PROGMEM gamma_table[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
    0x0b, 0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d,
    0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
    0x0f, 0x0f, 0x0f, 0x0f};

#endif // _GAMMA_H_


//EXAMPLE-4 this is my arduino code examle 16*32 scrolltext_16x32.ino

// scrolltext demo for Adafruit RGBmatrixPanel library.
// Demonstrates double-buffered animation on our 16x32 RGB LED matrix:
// http://www.adafruit.com/products/420
// DOUBLE-BUFFERED ANIMATION DOES NOT WORK WITH ARDUINO UNO or METRO 328.

// Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon
// for Adafruit Industries.
// BSD license, all text above must be included in any redistribution.

#include <RGBmatrixPanel.h>

// Most of the signal pins are configurable, but the CLK pin has some
// special constraints.  On 8-bit AVR boards it must be on PORTB...
// Pin 11 works on the Arduino Mega.  On 32-bit SAMD boards it must be
// on the same PORT as the RGB data pins (D2-D7)...
// Pin 8 works on the Adafruit Metro M0 or Arduino Zero,
// Pin A4 works on the Adafruit Metro M4 (if using the Adafruit RGB
// Matrix Shield, cut trace between CLK pads and run a wire to A4).

#define CLK  8   // USE THIS ON ADAFRUIT METRO M0, etc.
//#define CLK A4 // USE THIS ON METRO M4 (not M0)
//#define CLK 11 // USE THIS ON ARDUINO MEGA
#define OE   9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2

// Last parameter = 'true' enables double-buffering, for flicker-free,
// buttery smooth animation.  Note that NOTHING WILL SHOW ON THE DISPLAY
// until the first call to swapBuffers().  This is normal.
RGBmatrixPanel matrix(A, B, C, CLK, LAT, OE, true);

// Similar to F(), but for PROGMEM string pointers rather than literals
#define F2(progmem_ptr) (const __FlashStringHelper *)progmem_ptr

const char str[] PROGMEM = "Adafruit 16x32 RGB LED Matrix";
int16_t    textX         = matrix.width(),
           textMin       = (int16_t)sizeof(str) * -12,
           hue           = 0;
int8_t ball[3][4] = {
  {  3,  0,  1,  1 }, // Initial X,Y pos & velocity for 3 bouncy balls
  { 17, 15,  1, -1 },
  { 27,  4, -1,  1 }
};
static const uint16_t PROGMEM ballcolor[3] = {
  0x0080, // Green=1
  0x0002, // Blue=1
  0x1000  // Red=1
};

void setup() {
  matrix.begin();
  matrix.setTextWrap(false); // Allow text to run off right edge
  matrix.setTextSize(2);
}

void loop() {
  byte i;

  // Clear background
  matrix.fillScreen(0);

  // Bounce three balls around
  for(i=0; i<3; i++) {
    // Draw 'ball'
    matrix.fillCircle(ball[i][0], ball[i][1], 5, pgm_read_word(&ballcolor[i]));
    // Update X, Y position
    ball[i][0] += ball[i][2];
    ball[i][1] += ball[i][3];
    // Bounce off edges
    if((ball[i][0] == 0) || (ball[i][0] == (matrix.width() - 1)))
      ball[i][2] *= -1;
    if((ball[i][1] == 0) || (ball[i][1] == (matrix.height() - 1)))
      ball[i][3] *= -1;
  }

  // Draw big scrolly text on top
  matrix.setTextColor(matrix.ColorHSV(hue, 255, 255, true));
  matrix.setCursor(textX, 1);
  matrix.print(F2(str));

  // Move text left (w/wrap), increase hue
  if((--textX) < textMin) textX = matrix.width();
  hue += 7;
  if(hue >= 1536) hue -= 1536;

#if !defined(__AVR__)
  // On non-AVR boards, delay slightly so screen updates aren't too quick.
  delay(20);
#endif

  // Update display
  matrix.swapBuffers(false);
}

//EXAMPLE-5 testcolors_16x32.ino
// testcolors demo for Adafruit RGBmatrixPanel library.
// Renders 512 colors on our 16x32 RGB LED matrix:
// http://www.adafruit.com/products/420
// Library supports 4096 colors, but there aren't that many pixels!  :)

// Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon
// for Adafruit Industries.
// BSD license, all text above must be included in any redistribution.

#include <RGBmatrixPanel.h>

// Most of the signal pins are configurable, but the CLK pin has some
// special constraints.  On 8-bit AVR boards it must be on PORTB...
// Pin 8 works on the Arduino Uno & compatibles (e.g. Adafruit Metro),
// Pin 11 works on the Arduino Mega.  On 32-bit SAMD boards it must be
// on the same PORT as the RGB data pins (D2-D7)...
// Pin 8 works on the Adafruit Metro M0 or Arduino Zero,
// Pin A4 works on the Adafruit Metro M4 (if using the Adafruit RGB
// Matrix Shield, cut trace between CLK pads and run a wire to A4).

#define CLK  8   // USE THIS ON ARDUINO UNO, ADAFRUIT METRO M0, etc.
//#define CLK A4 // USE THIS ON METRO M4 (not M0)
//#define CLK 11 // USE THIS ON ARDUINO MEGA
#define OE   9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2

RGBmatrixPanel matrix(A, B, C, CLK, LAT, OE, false);

void setup() {
  matrix.begin();
  uint8_t r=0, g=0, b=0;

  // Draw top half
  for(uint8_t x=0; x<32; x++) {
    for(uint8_t y=0; y<8; y++) {
      matrix.drawPixel(x, y, matrix.Color333(r, g, b));
      r++;
      if(r == 8) {
        r = 0;
        g++;
        if(g == 8) {
          g = 0;
          b++;
        }
      }
    }
  }

  // Draw bottom half
  for(uint8_t x=0; x<32; x++) {
    for(uint8_t y=8; y<16; y++) {
      matrix.drawPixel(x, y, matrix.Color333(r, g, b));
      r++;
      if(r == 8) {
        r = 0;
        g++;
        if(g == 8) {
          g = 0;
          b++;
        }
      }
    }
  }
}

void loop() {
  // Do nothing -- image doesn't change
}

//EXAMPLE-6 testshapes_16x32.ino
// testshapes demo for Adafruit RGBmatrixPanel library.
// Demonstrates the drawing abilities of the RGBmatrixPanel library.
// For 16x32 RGB LED matrix:
// http://www.adafruit.com/products/420

// Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon
// for Adafruit Industries.
// BSD license, all text above must be included in any redistribution.

#include <RGBmatrixPanel.h>

// Most of the signal pins are configurable, but the CLK pin has some
// special constraints.  On 8-bit AVR boards it must be on PORTB...
// Pin 8 works on the Arduino Uno & compatibles (e.g. Adafruit Metro),
// Pin 11 works on the Arduino Mega.  On 32-bit SAMD boards it must be
// on the same PORT as the RGB data pins (D2-D7)...
// Pin 8 works on the Adafruit Metro M0 or Arduino Zero,
// Pin A4 works on the Adafruit Metro M4 (if using the Adafruit RGB
// Matrix Shield, cut trace between CLK pads and run a wire to A4).

#define CLK  8   // USE THIS ON ARDUINO UNO, ADAFRUIT METRO M0, etc.
//#define CLK A4 // USE THIS ON METRO M4 (not M0)
//#define CLK 11 // USE THIS ON ARDUINO MEGA
#define OE   9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2

RGBmatrixPanel matrix(A, B, C, CLK, LAT, OE, false);

void setup() {

  matrix.begin();

  // draw a pixel in white
  matrix.drawPixel(0, 0, matrix.Color333(7, 7, 7));
  delay(500);

  // fix the screen with green
  matrix.fillRect(0, 0, 32, 16, matrix.Color333(0, 7, 0));
  delay(500);

  // draw a box in yellow
  matrix.drawRect(0, 0, 32, 16, matrix.Color333(7, 7, 0));
  delay(500);

  // draw an 'X' in red
  matrix.drawLine(0, 0, 31, 15, matrix.Color333(7, 0, 0));
  matrix.drawLine(31, 0, 0, 15, matrix.Color333(7, 0, 0));
  delay(500);

  // draw a blue circle
  matrix.drawCircle(7, 7, 7, matrix.Color333(0, 0, 7));
  delay(500);

  // fill a violet circle
  matrix.fillCircle(23, 7, 7, matrix.Color333(7, 0, 7));
  delay(500);

  // fill the screen with black
  matrix.fillScreen(matrix.Color333(0, 0, 0));

  // draw some text!
  matrix.setCursor(1, 0);  // start at top left, with one pixel of spacing
  matrix.setTextSize(1);   // size 1 == 8 pixels high

  // print each letter with a rainbow color
  matrix.setTextColor(matrix.Color333(7,0,0));
  matrix.print('1');
  matrix.setTextColor(matrix.Color333(7,4,0));
  matrix.print('6');
  matrix.setTextColor(matrix.Color333(7,7,0));
  matrix.print('x');
  matrix.setTextColor(matrix.Color333(4,7,0));
  matrix.print('3');
  matrix.setTextColor(matrix.Color333(0,7,0));
  matrix.print('2');

  matrix.setCursor(1, 9);  // next line
  matrix.setTextColor(matrix.Color333(0,7,7));
  matrix.print('*');
  matrix.setTextColor(matrix.Color333(0,4,7));
  matrix.print('R');
  matrix.setTextColor(matrix.Color333(0,0,7));
  matrix.print('G');
  matrix.setTextColor(matrix.Color333(4,0,7));
  matrix.print('B');
  matrix.setTextColor(matrix.Color333(7,0,4));
  matrix.print('*');

  // whew!
}

void loop() {
  // Do nothing -- image doesn't change
}

//EXAMPLE-6 plasma_16x32.ino

// plasma demo for Adafruit RGBmatrixPanel library.
// Demonstrates double-buffered animation our 16x32 RGB LED matrix:
// http://www.adafruit.com/products/420
// DOUBLE-BUFFERED ANIMATION DOES NOT WORK WITH ARDUINO UNO or METRO 328.

// Written by Limor Fried/Ladyada & Phil Burgess/PaintYourDragon
// for Adafruit Industries.
// BSD license, all text above must be included in any redistribution.

#include <RGBmatrixPanel.h>

// Most of the signal pins are configurable, but the CLK pin has some
// special constraints.  On 8-bit AVR boards it must be on PORTB...
// Pin 11 works on the Arduino Mega.  On 32-bit SAMD boards it must be
// on the same PORT as the RGB data pins (D2-D7)...
// Pin 8 works on the Adafruit Metro M0 or Arduino Zero,
// Pin A4 works on the Adafruit Metro M4 (if using the Adafruit RGB
// Matrix Shield, cut trace between CLK pads and run a wire to A4).

#define CLK  8   // USE THIS ON ADAFRUIT METRO M0, etc.
//#define CLK A4 // USE THIS ON METRO M4 (not M0)
//#define CLK 11 // USE THIS ON ARDUINO MEGA
#define OE   9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2

// Last parameter = 'true' enables double-buffering, for flicker-free,
// buttery smooth animation.  Note that NOTHING WILL SHOW ON THE DISPLAY
// until the first call to swapBuffers().  This is normal.
RGBmatrixPanel matrix(A, B, C, CLK, LAT, OE, true);

static const int8_t PROGMEM sinetab[256] = {
     0,   2,   5,   8,  11,  15,  18,  21,
    24,  27,  30,  33,  36,  39,  42,  45,
    48,  51,  54,  56,  59,  62,  65,  67,
    70,  72,  75,  77,  80,  82,  85,  87,
    89,  91,  93,  96,  98, 100, 101, 103,
   105, 107, 108, 110, 111, 113, 114, 116,
   117, 118, 119, 120, 121, 122, 123, 123,
   124, 125, 125, 126, 126, 126, 126, 126,
   127, 126, 126, 126, 126, 126, 125, 125,
   124, 123, 123, 122, 121, 120, 119, 118,
   117, 116, 114, 113, 111, 110, 108, 107,
   105, 103, 101, 100,  98,  96,  93,  91,
    89,  87,  85,  82,  80,  77,  75,  72,
    70,  67,  65,  62,  59,  56,  54,  51,
    48,  45,  42,  39,  36,  33,  30,  27,
    24,  21,  18,  15,  11,   8,   5,   2,
     0,  -3,  -6,  -9, -12, -16, -19, -22,
   -25, -28, -31, -34, -37, -40, -43, -46,
   -49, -52, -55, -57, -60, -63, -66, -68,
   -71, -73, -76, -78, -81, -83, -86, -88,
   -90, -92, -94, -97, -99,-101,-102,-104,
  -106,-108,-109,-111,-112,-114,-115,-117,
  -118,-119,-120,-121,-122,-123,-124,-124,
  -125,-126,-126,-127,-127,-127,-127,-127,
  -128,-127,-127,-127,-127,-127,-126,-126,
  -125,-124,-124,-123,-122,-121,-120,-119,
  -118,-117,-115,-114,-112,-111,-109,-108,
  -106,-104,-102,-101, -99, -97, -94, -92,
   -90, -88, -86, -83, -81, -78, -76, -73,
   -71, -68, -66, -63, -60, -57, -55, -52,
   -49, -46, -43, -40, -37, -34, -31, -28,
   -25, -22, -19, -16, -12,  -9,  -6,  -3
};

void setup() {
  matrix.begin();
}

const float radius1 =65.2, radius2 =92.0, radius3 =163.2, radius4 =176.8,
            centerx1=64.4, centerx2=46.4, centerx3= 93.6, centerx4= 16.4,
            centery1=34.8, centery2=26.0, centery3= 56.0, centery4=-11.6;
float       angle1  = 0.0, angle2  = 0.0, angle3  =  0.0, angle4  =  0.0;
long        hueShift= 0;

#define FPS 15         // Maximum frames-per-second
uint32_t prevTime = 0; // For frame-to-frame interval timing

void loop() {
  int           x1, x2, x3, x4, y1, y2, y3, y4, sx1, sx2, sx3, sx4;
  unsigned char x, y;
  long          value;

  sx1 = (int)(cos(angle1) * radius1 + centerx1);
  sx2 = (int)(cos(angle2) * radius2 + centerx2);
  sx3 = (int)(cos(angle3) * radius3 + centerx3);
  sx4 = (int)(cos(angle4) * radius4 + centerx4);
  y1  = (int)(sin(angle1) * radius1 + centery1);
  y2  = (int)(sin(angle2) * radius2 + centery2);
  y3  = (int)(sin(angle3) * radius3 + centery3);
  y4  = (int)(sin(angle4) * radius4 + centery4);

  for(y=0; y<matrix.height(); y++) {
    x1 = sx1; x2 = sx2; x3 = sx3; x4 = sx4;
    for(x=0; x<matrix.width(); x++) {
      value = hueShift
        + (int8_t)pgm_read_byte(sinetab + (uint8_t)((x1 * x1 + y1 * y1) >> 4))
        + (int8_t)pgm_read_byte(sinetab + (uint8_t)((x2 * x2 + y2 * y2) >> 4))
        + (int8_t)pgm_read_byte(sinetab + (uint8_t)((x3 * x3 + y3 * y3) >> 5))
        + (int8_t)pgm_read_byte(sinetab + (uint8_t)((x4 * x4 + y4 * y4) >> 5));
      matrix.drawPixel(x, y, matrix.ColorHSV(value * 3, 255, 255, true));
      x1--; x2--; x3--; x4--;
    }
    y1--; y2--; y3--; y4--;
  }

  angle1   += 0.03;
  angle2   -= 0.07;
  angle3   += 0.13;
  angle4   -= 0.15;
  hueShift += 2;

  // To ensure that animation speed is similar on AVR & SAMD boards,
  // limit frame rate to FPS value (might go slower, but never faster).
  // This is preferable to delay() because the AVR is already plenty slow.
  uint32_t t;
  while(((t = millis()) - prevTime) < (1000 / FPS));
  prevTime = t;

  matrix.swapBuffers(false);
}

//EXAMPLE-7 PanelGFXDemo_16x32.ino

// RGB Panel GFX Demo example for 16x32 panel
// By Marc MERLIN <marc_soft@merlins.org>
// Contains code (c) Adafruit, license BSD

// WILL NOT FIT on ARDUINO UNO -- requires a Mega, M0 or M4 board

#include <RGBmatrixPanel.h>
#include "smileytongue24.h"

// Most of the signal pins are configurable, but the CLK pin has some
// special constraints.  On 8-bit AVR boards it must be on PORTB...
// Pin 11 works on the Arduino Mega.  On 32-bit SAMD boards it must be
// on the same PORT as the RGB data pins (D2-D7)...
// Pin 8 works on the Adafruit Metro M0 or Arduino Zero,
// Pin A4 works on the Adafruit Metro M4 (if using the Adafruit RGB
// Matrix Shield, cut trace between CLK pads and run a wire to A4).

#define CLK  8   // USE THIS ON ADAFRUIT METRO M0, etc.
//#define CLK A4 // USE THIS ON METRO M4 (not M0)
//#define CLK 11 // USE THIS ON ARDUINO MEGA
#define OE   9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2

// Enable double buffering
RGBmatrixPanel *matrix = new RGBmatrixPanel(A, B, C, CLK, LAT, OE, true);

// Panel Matrix doesn't fully work like Neomatrix (which I originally
// wrote this demo for), so map a few calls to be compatible. The rest
// comes from Adafruit_GFX and works the same on both backends.
#define setBrightness(x) fillScreen(0) // no-op, no brightness on this board
#define clear()          fillScreen(0)
#define show()           swapBuffers(true)
#define Color(x,y,z)     Color444(x/16,y/16,z/16)

// Define matrix width and height.
#define mw 32
#define mh 16

// This could also be defined as matrix->color(255,0,0) but those defines
// are meant to work for Adafruit::GFX backends that are lacking color()
#define LED_BLACK           0

#define LED_RED_VERYLOW    (3 <<  11)
#define LED_RED_LOW        (7 <<  11)
#define LED_RED_MEDIUM     (15 << 11)
#define LED_RED_HIGH       (31 << 11)

#define LED_GREEN_VERYLOW  (1 <<  5)
#define LED_GREEN_LOW      (15 << 5)
#define LED_GREEN_MEDIUM   (31 << 5)
#define LED_GREEN_HIGH     (63 << 5)

#define LED_BLUE_VERYLOW     3
#define LED_BLUE_LOW         7
#define LED_BLUE_MEDIUM     15
#define LED_BLUE_HIGH       31

#define LED_ORANGE_VERYLOW (LED_RED_VERYLOW + LED_GREEN_VERYLOW)
#define LED_ORANGE_LOW     (LED_RED_LOW     + LED_GREEN_LOW)
#define LED_ORANGE_MEDIUM  (LED_RED_MEDIUM  + LED_GREEN_MEDIUM)
#define LED_ORANGE_HIGH    (LED_RED_HIGH    + LED_GREEN_HIGH)

#define LED_PURPLE_VERYLOW (LED_RED_VERYLOW + LED_BLUE_VERYLOW)
#define LED_PURPLE_LOW     (LED_RED_LOW     + LED_BLUE_LOW)
#define LED_PURPLE_MEDIUM  (LED_RED_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_PURPLE_HIGH    (LED_RED_HIGH    + LED_BLUE_HIGH)

#define LED_CYAN_VERYLOW   (LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_CYAN_LOW       (LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_CYAN_MEDIUM    (LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_CYAN_HIGH      (LED_GREEN_HIGH    + LED_BLUE_HIGH)

#define LED_WHITE_VERYLOW  (LED_RED_VERYLOW + LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_WHITE_LOW      (LED_RED_LOW     + LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_WHITE_MEDIUM   (LED_RED_MEDIUM  + LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_WHITE_HIGH     (LED_RED_HIGH    + LED_GREEN_HIGH    + LED_BLUE_HIGH)

static const uint8_t PROGMEM
    mono_bmp[][8] =
    {
        {   B10101010, // 0: checkered 1
            B01010101,
            B10101010,
            B01010101,
            B10101010,
            B01010101,
            B10101010,
            B01010101 },
        {   B01010101, // 1: checkered 2
            B10101010,
            B01010101,
            B10101010,
            B01010101,
            B10101010,
            B01010101,
            B10101010 },
        {   B00111100, // 2: smiley
            B01000010,
            B10100101,
            B10000001,
            B10100101,
            B10011001,
            B01000010,
            B00111100 },
        {   B00111100, // 3: neutral
            B01000010,
            B10100101,
            B10000001,
            B10111101,
            B10000001,
            B01000010,
            B00111100 },
        {   B00111100, // 4; frowny
            B01000010,
            B10100101,
            B10000001,
            B10011001,
            B10100101,
            B01000010,
            B00111100 },
    };

static const uint16_t PROGMEM
    // These bitmaps were written for a backend that only supported
    // 4 bits per color with Blue/Green/Red ordering while neomatrix
    // uses native 565 color mapping as RGB.
    // I'm leaving the arrays as is because it's easier to read
    // which color is what when separated on a 4bit boundary
    // The demo code will modify the arrays at runtime to be compatible
    // with the neomatrix color ordering and bit depth.
    RGB_bmp[][64] = {
      // 00: blue, blue/red, red, red/green, green, green/blue, blue, white
      { 0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00,
        0x101, 0x202, 0x303, 0x404, 0x606, 0x808, 0xA0A, 0xF0F,
        0x001, 0x002, 0x003, 0x004, 0x006, 0x008, 0x00A, 0x00F,
        0x011, 0x022, 0x033, 0x044, 0x066, 0x088, 0x0AA, 0x0FF,
        0x010, 0x020, 0x030, 0x040, 0x060, 0x080, 0x0A0, 0x0F0,
        0x110, 0x220, 0x330, 0x440, 0x660, 0x880, 0xAA0, 0xFF0,
        0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00,
        0x111, 0x222, 0x333, 0x444, 0x666, 0x888, 0xAAA, 0xFFF, },

      // 01: grey to white
      { 0x111, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
        0x222, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
        0x333, 0x333, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
        0x555, 0x555, 0x555, 0x555, 0x777, 0x999, 0xAAA, 0xFFF,
        0x777, 0x777, 0x777, 0x777, 0x777, 0x999, 0xAAA, 0xFFF,
        0x999, 0x999, 0x999, 0x999, 0x999, 0x999, 0xAAA, 0xFFF,
        0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xFFF,
        0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, },

      // 02: low red to high red
      { 0x001, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
        0x002, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
        0x003, 0x003, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F,
        0x005, 0x005, 0x005, 0x005, 0x007, 0x009, 0x00A, 0x00F,
        0x007, 0x007, 0x007, 0x007, 0x007, 0x009, 0x00A, 0x00F,
        0x009, 0x009, 0x009, 0x009, 0x009, 0x009, 0x00A, 0x00F,
        0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00F,
        0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, },

      // 03: low green to high green
      { 0x010, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
        0x020, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
        0x030, 0x030, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
        0x050, 0x050, 0x050, 0x050, 0x070, 0x090, 0x0A0, 0x0F0,
        0x070, 0x070, 0x070, 0x070, 0x070, 0x090, 0x0A0, 0x0F0,
        0x090, 0x090, 0x090, 0x090, 0x090, 0x090, 0x0A0, 0x0F0,
        0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0F0,
        0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, },

      // 04: low blue to high blue
      { 0x100, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
        0x200, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
        0x300, 0x300, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00,
        0x500, 0x500, 0x500, 0x500, 0x700, 0x900, 0xA00, 0xF00,
        0x700, 0x700, 0x700, 0x700, 0x700, 0x900, 0xA00, 0xF00,
        0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0xA00, 0xF00,
        0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xF00,
        0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, },

      // 05: 1 black, 2R, 2O, 2G, 1B with 4 blue lines rising right
      { 0x000, 0x200, 0x000, 0x400, 0x000, 0x800, 0x000, 0xF00,
        0x000, 0x201, 0x002, 0x403, 0x004, 0x805, 0x006, 0xF07,
        0x008, 0x209, 0x00A, 0x40B, 0x00C, 0x80D, 0x00E, 0xF0F,
        0x000, 0x211, 0x022, 0x433, 0x044, 0x855, 0x066, 0xF77,
        0x088, 0x299, 0x0AA, 0x4BB, 0x0CC, 0x8DD, 0x0EE, 0xFFF,
        0x000, 0x210, 0x020, 0x430, 0x040, 0x850, 0x060, 0xF70,
        0x080, 0x290, 0x0A0, 0x4B0, 0x0C0, 0x8D0, 0x0E0, 0xFF0,
        0x000, 0x200, 0x000, 0x500, 0x000, 0x800, 0x000, 0xF00, },

      // 06: 4 lines of increasing red and then green
      { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003,
        0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007,
        0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B,
        0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F,
        0x000, 0x000, 0x010, 0x010, 0x020, 0x020, 0x030, 0x030,
        0x040, 0x040, 0x050, 0x050, 0x060, 0x060, 0x070, 0x070,
        0x080, 0x080, 0x090, 0x090, 0x0A0, 0x0A0, 0x0B0, 0x0B0,
        0x0C0, 0x0C0, 0x0D0, 0x0D0, 0x0E0, 0x0E0, 0x0F0, 0x0F0, },

      // 07: 4 lines of increasing red and then blue
      { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003,
        0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007,
        0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B,
        0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F,
        0x000, 0x000, 0x100, 0x100, 0x200, 0x200, 0x300, 0x300,
        0x400, 0x400, 0x500, 0x500, 0x600, 0x600, 0x700, 0x700,
        0x800, 0x800, 0x900, 0x900, 0xA00, 0xA00, 0xB00, 0xB00,
        0xC00, 0xC00, 0xD00, 0xD00, 0xE00, 0xE00, 0xF00, 0xF00, },

      // 08: criss cross of green and red with diagonal blue.
      { 0xF00, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0x000,
        0x020, 0xF21, 0x023, 0x025, 0x027, 0x02A, 0x02F, 0x020,
        0x040, 0x041, 0xF43, 0x045, 0x047, 0x04A, 0x04F, 0x040,
        0x060, 0x061, 0x063, 0xF65, 0x067, 0x06A, 0x06F, 0x060,
        0x080, 0x081, 0x083, 0x085, 0xF87, 0x08A, 0x08F, 0x080,
        0x0A0, 0x0A1, 0x0A3, 0x0A5, 0x0A7, 0xFAA, 0x0AF, 0x0A0,
        0x0F0, 0x0F1, 0x0F3, 0x0F5, 0x0F7, 0x0FA, 0xFFF, 0x0F0,
        0x000, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0xF00, },

      // 09: 2 lines of green, 2 red, 2 orange, 2 green
      { 0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0,
        0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, },

      // 10: multicolor smiley face
      { 0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000,
        0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
        0x00F, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x00F,
        0x00F, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x00F,
        0x00F, 0x000, 0x0F0, 0x000, 0x000, 0x0F0, 0x000, 0x00F,
        0x00F, 0x000, 0x000, 0x0F4, 0x0F3, 0x000, 0x000, 0x00F,
        0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000,
        0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000, },
};


// Convert a BGR 4/4/4 bitmap to RGB 5/6/5 used by Adafruit_GFX
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
    uint16_t RGB_bmp_fixed[w * h];
    for (uint16_t pixel=0; pixel<w*h; pixel++) {
        uint8_t r,g,b;
        uint16_t color = pgm_read_word(bitmap + pixel);

        //Serial.print(color, HEX);
        b = (color & 0xF00) >> 8;
        g = (color & 0x0F0) >> 4;
        r = color & 0x00F;
        //Serial.print(" ");
        //Serial.print(b);
        //Serial.print("/");
        //Serial.print(g);
        //Serial.print("/");
        //Serial.print(r);
        //Serial.print(" -> ");
        // expand from 4/4/4 bits per color to 5/6/5
        b = map(b, 0, 15, 0, 31);
        g = map(g, 0, 15, 0, 63);
        r = map(r, 0, 15, 0, 31);
        //Serial.print(r);
        //Serial.print("/");
        //Serial.print(g);
        //Serial.print("/");
        //Serial.print(b);
        RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
        //Serial.print(" -> ");
        //Serial.println(RGB_bmp_fixed[pixel], HEX);
    }
    matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}

// Fill the screen with multiple levels of white to gauge the quality
void display_four_white() {
    matrix->clear();
    matrix->fillRect(0,0, mw,mh, LED_WHITE_HIGH);
    matrix->drawRect(1,1, mw-2,mh-2, LED_WHITE_MEDIUM);
    matrix->drawRect(2,2, mw-4,mh-4, LED_WHITE_LOW);
    matrix->drawRect(3,3, mw-6,mh-6, LED_WHITE_VERYLOW);
    matrix->show();
}

void display_bitmap(uint8_t bmp_num, uint16_t color) {
    static uint16_t bmx,bmy;

    // Clear the space under the bitmap that will be drawn as
    // drawing a single color pixmap does not write over pixels
    // that are nul, and leaves the data that was underneath
    matrix->fillRect(bmx,bmy, bmx+8,bmy+8, LED_BLACK);
    matrix->drawBitmap(bmx, bmy, mono_bmp[bmp_num], 8, 8, color);
    bmx += 8;
    if (bmx >= mw) bmx = 0;
    if (!bmx) bmy += 8;
    if (bmy >= mh) bmy = 0;
    matrix->show();
}

void display_rgbBitmap(uint8_t bmp_num) {
    static uint16_t bmx,bmy;

    fixdrawRGBBitmap(bmx, bmy, RGB_bmp[bmp_num], 8, 8);
    bmx += 8;
    if (bmx >= mw) bmx = 0;
    if (!bmx) bmy += 8;
    if (bmy >= mh) bmy = 0;
    matrix->show();
}

void display_lines() {
    matrix->clear();

    // 4 levels of crossing red lines.
    matrix->drawLine(0,mh/2-2, mw-1,2, LED_RED_VERYLOW);
    matrix->drawLine(0,mh/2-1, mw-1,3, LED_RED_LOW);
    matrix->drawLine(0,mh/2,   mw-1,mh/2, LED_RED_MEDIUM);
    matrix->drawLine(0,mh/2+1, mw-1,mh/2+1, LED_RED_HIGH);

    // 4 levels of crossing green lines.
    matrix->drawLine(mw/2-2, 0, mw/2-2, mh-1, LED_GREEN_VERYLOW);
    matrix->drawLine(mw/2-1, 0, mw/2-1, mh-1, LED_GREEN_LOW);
    matrix->drawLine(mw/2+0, 0, mw/2+0, mh-1, LED_GREEN_MEDIUM);
    matrix->drawLine(mw/2+1, 0, mw/2+1, mh-1, LED_GREEN_HIGH);

    // Diagonal blue line.
    matrix->drawLine(0,0, mw-1,mh-1, LED_BLUE_HIGH);
    matrix->drawLine(0,mh-1, mw-1,0, LED_ORANGE_MEDIUM);
    matrix->show();
}

void display_boxes() {
    matrix->clear();
    matrix->drawRect(0,0, mw,mh, LED_BLUE_HIGH);
    matrix->drawRect(1,1, mw-2,mh-2, LED_GREEN_MEDIUM);
    matrix->fillRect(2,2, mw-4,mh-4, LED_RED_HIGH);
    matrix->fillRect(3,3, mw-6,mh-6, LED_ORANGE_MEDIUM);
    matrix->show();
}

void display_circles() {
    matrix->clear();
    matrix->drawCircle(mw/2,mh/2, 2, LED_RED_MEDIUM);
    matrix->drawCircle(mw/2-1-min(mw,mh)/8, mh/2-1-min(mw,mh)/8, min(mw,mh)/4, LED_BLUE_HIGH);
    matrix->drawCircle(mw/2+1+min(mw,mh)/8, mh/2+1+min(mw,mh)/8, min(mw,mh)/4, LED_ORANGE_MEDIUM);
    matrix->drawCircle(1,mh-2, 1, LED_GREEN_LOW);
    matrix->drawCircle(mw-2,1, 1, LED_GREEN_HIGH);
    matrix->show();
}

void display_resolution() {
    // not wide enough;
    if (mw<16) return;
    matrix->clear();
    // Font is 5x7, if display is too small
    // 8 can only display 1 char
    // 16 can almost display 3 chars
    // 24 can display 4 chars
    // 32 can display 5 chars
    matrix->setCursor(0, 0);
    matrix->setTextColor(matrix->Color(255,0,0));
    if (mw>10) matrix->print(mw/10);
    matrix->setTextColor(matrix->Color(255,128,0));
    matrix->print(mw % 10);
    matrix->setTextColor(matrix->Color(0,255,0));
    matrix->print('x');
    // not wide enough to print 5 chars, go to next line
    if (mw<25) {
        if (mh==13) matrix->setCursor(6, 7);
        else if (mh>=13) {
            matrix->setCursor(mw-11, 8);
        } else {
            matrix->show();
            delay(2000);
            matrix->clear();
            matrix->setCursor(mw-11, 0);
        }
    }
    matrix->setTextColor(matrix->Color(0,255,128));
    matrix->print(mh/10);
    matrix->setTextColor(matrix->Color(0,128,255));
    matrix->print(mh % 10);
    // enough room for a 2nd line
    if (mw>25 && mh >14 || mh>16) {
        matrix->setCursor(0, mh-7);
        matrix->setTextColor(matrix->Color(0,255,255));
        if (mw>16) matrix->print('*');
        matrix->setTextColor(matrix->Color(255,0,0));
        matrix->print('R');
        matrix->setTextColor(matrix->Color(0,255,0));
        matrix->print('G');
        matrix->setTextColor(matrix->Color(0,0,255));
        matrix->print("B");
        matrix->setTextColor(matrix->Color(255,255,0));
        matrix->print("*");
    }

    matrix->show();
}

void display_scrollText() {
    matrix->clear();
    matrix->setTextWrap(false);  // we don't wrap text so it scrolls nicely
    matrix->setTextSize(1);
    matrix->setRotation(0);
    for (int8_t x=7; x>=-42; x--) {
        matrix->clear();
        matrix->setCursor(x,0);
        matrix->setTextColor(LED_GREEN_HIGH);
        matrix->print("Hello");
        if (mh>11) {
            matrix->setCursor(-20-x,mh-7);
            matrix->setTextColor(LED_ORANGE_HIGH);
            matrix->print("World");
        }
        matrix->show();
        delay(50);
    }

    matrix->setRotation(3);
    matrix->setTextColor(LED_BLUE_HIGH);
    for (int8_t x=7; x>=-45; x--) {
        matrix->clear();
        matrix->setCursor(x,mw/2-4);
        matrix->print("Rotate");
        matrix->show();
        delay(50);
    }
    matrix->setRotation(0);
    matrix->setCursor(0,0);
    matrix->show();
}

// Scroll within big bitmap so that all if it becomes visible or bounce a
// small one.  If the bitmap is bigger in one dimension and smaller in the
// other one, it will both pan and bounce in the appropriate dimensions.
void display_panOrBounceBitmap (uint8_t bitmapSize) {
    // keep integer math, deal with values 16 times too big
    // start by showing upper left of big bitmap or centering if big display
    int16_t xf = max(0, (mw-bitmapSize)/2) << 4;
    int16_t yf = max(0, (mh-bitmapSize)/2) << 4;
    // scroll speed in 1/16th
    int16_t xfc = 6;
    int16_t yfc = 3;
    // scroll down and right by moving upper left corner off screen
    // more up and left (which means negative numbers)
    int16_t xfdir = -1;
    int16_t yfdir = -1;

    for (uint16_t i=1; i<1000; i++) {
        bool updDir = false;

        // Get actual x/y by dividing by 16.
        int16_t x = xf >> 4;
        int16_t y = yf >> 4;

        matrix->clear();
        // bounce 8x8 tri color smiley face around the screen
        if (bitmapSize == 8) fixdrawRGBBitmap(x, y, RGB_bmp[10], 8, 8);
        // pan 24x24 pixmap
        if (bitmapSize == 24) matrix->drawRGBBitmap(x, y, (const uint16_t *)bitmap24, bitmapSize, bitmapSize);
        matrix->show();

        // Only pan if the display size is smaller than the pixmap
        if (mw<bitmapSize) {
            xf += xfc*xfdir;
            if (xf >= 0)                      { xfdir = -1; updDir = true ; };
            // we don't go negative past right corner, go back positive
            if (xf <= ((mw-bitmapSize) << 4)) { xfdir = 1;  updDir = true ; };
        }
        if (mh<bitmapSize) {
            yf += yfc*yfdir;
            // we shouldn't display past left corner, reverse direction.
            if (yf >= 0)                      { yfdir = -1; updDir = true ; };
            if (yf <= ((mh-bitmapSize) << 4)) { yfdir = 1;  updDir = true ; };
        }
        // only bounce a pixmap if it's smaller than the display size
        if (mw>bitmapSize) {
            xf += xfc*xfdir;
            // Deal with bouncing off the 'walls'
            if (xf >= (mw-bitmapSize) << 4) { xfdir = -1; updDir = true ; };
            if (xf <= 0)                    { xfdir =  1; updDir = true ; };
        }
        if (mh>bitmapSize) {
            yf += yfc*yfdir;
            if (yf >= (mh-bitmapSize) << 4) { yfdir = -1; updDir = true ; };
            if (yf <= 0)                    { yfdir =  1; updDir = true ; };
        }

       if (updDir) {
            // Add -1, 0 or 1 but bind result to 1 to 1.
            // Let's take 3 is a minimum speed, otherwise it's too slow.
            xfc = constrain(xfc + random(-1, 2), 3, 16);
            yfc = constrain(xfc + random(-1, 2), 3, 16);
        }
        delay(10);
    }
}


void loop() {
    // clear the screen after X bitmaps have been displayed and we
    // loop back to the top left corner
    // 8x8 => 1, 16x8 => 2, 17x9 => 6
    static uint8_t pixmap_count = ((mw+7)/8) * ((mh+7)/8);

    Serial.print("Screen pixmap capacity: ");
    Serial.println(pixmap_count);

    // multicolor bitmap sent as many times as we can display an 8x8 pixmap
    for (uint8_t i=0; i<=pixmap_count; i++) {
        display_rgbBitmap(0);
    }
    delay(1000);

    display_resolution();
    delay(3000);

    // Cycle through red, green, blue, display 2 checkered patterns
    // useful to debug some screen types and alignment.
    uint16_t bmpcolor[] = { LED_GREEN_HIGH, LED_BLUE_HIGH, LED_RED_HIGH };
    for (uint8_t i=0; i<3; i++) {
        display_bitmap(0, bmpcolor[i]);
        delay(500);
        display_bitmap(1, bmpcolor[i]);
        delay(500);
    }

    // Display 3 smiley faces.
    for (uint8_t i=2; i<=4; i++) {
        display_bitmap(i, bmpcolor[i-2]);
        // If more than one pixmap displayed per screen, display more quickly.
        delay(mw>8?500:1500);
    }
    // If we have multiple pixmaps displayed at once, wait a bit longer on the last.
    delay(mw>8?1000:500);

    display_lines();
    delay(3000);

    display_boxes();
    delay(3000);

    display_circles();
    delay(3000);

    for (uint8_t i=0; i<=(sizeof(RGB_bmp)/sizeof(RGB_bmp[0])-1); i++) {
        display_rgbBitmap(i);
        delay(mw>8?500:1500);
    }
    // If we have multiple pixmaps displayed at once, wait a bit longer on the last.
    delay(mw>8?1000:500);

    display_four_white();
    delay(3000);

    display_scrollText();

    // pan a big pixmap
    display_panOrBounceBitmap(24);
    // bounce around a small one
    display_panOrBounceBitmap(8);
}

void setup() {
    Serial.begin(115200);
    matrix->begin();
    matrix->setTextWrap(false);
    matrix->setBrightness(BRIGHTNESS);
    // Test full bright of all LEDs. If brightness is too high
    // for your current limit (i.e. USB), decrease it.
    matrix->fillScreen(LED_WHITE_HIGH);
    matrix->show();
    delay(1000);
    matrix->clear();
}

// vim:sts=4:sw=4
